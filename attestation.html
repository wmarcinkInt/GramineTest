<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Attestation and Secret Provisioning &mdash; Gramine  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/gramine.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Performance tuning and analysis" href="performance.html" />
    <link rel="prev" title="Manifest syntax" href="manifest-syntax.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/gramine_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Start Here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Installation-index.html">Select a Deployment Option</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Ready-Made Application</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="curated-installation.html">Ready-made Confidential compute images</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Protect Your Container</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gsc-installation.html">Gramine Shielded Containers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Custom Build Gramine</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="custom-installation.html">Quick Install or Custom Build Gramine</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="configuration-index.html">Configure Gramine</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="manifest-syntax.html">Manifest syntax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Attestation and Secret Provisioning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#remote-attestation-flows-for-epid-and-dcap">Remote Attestation flows for EPID and DCAP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#low-level-dev-attestation-interface">Low-level <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mid-level-ra-tls-interface">Mid-level RA-TLS interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ra-tls-attest-so"><code class="docutils literal notranslate"><span class="pre">ra_tls_attest.so</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ra-tls-verify-epid-so"><code class="docutils literal notranslate"><span class="pre">ra_tls_verify_epid.so</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ra-tls-verify-dcap-so"><code class="docutils literal notranslate"><span class="pre">ra_tls_verify_dcap.so</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#high-level-secret-provisioning-interface">High-level Secret Provisioning interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#secret-prov-attest-so"><code class="docutils literal notranslate"><span class="pre">secret_prov_attest.so</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#secret-prov-verify-epid-so"><code class="docutils literal notranslate"><span class="pre">secret_prov_verify_epid.so</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#secret-prov-verify-dcap-so"><code class="docutils literal notranslate"><span class="pre">secret_prov_verify_dcap.so</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#third-party-solutions">Third-Party Solutions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#edgeless-marblerun">Edgeless Marblerun</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance tuning and analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="manpages/index.html">Manual pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer-index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials-index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="concepts-index.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributor-index.html">Contribution Guidelines</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resource</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="management-team.html">Management Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="gramine-users.html">Users of Gramine</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Gramine</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="configuration-index.html">Configure Gramine</a></li>
      <li class="breadcrumb-item active">Attestation and Secret Provisioning</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/attestation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">


           <div itemprop="articleBody">
             
  <section id="attestation-and-secret-provisioning">
<h1>Attestation and Secret Provisioning<a class="headerlink" href="#attestation-and-secret-provisioning" title="Permalink to this headline"></a></h1>
<p>Gramine is typically used to create and run Trusted Execution Environments
(<a class="reference internal" href="sgx-intro.html#term-TEE"><span class="xref std std-term">TEE</span></a>). A very important aspect of a TEE is <a class="reference internal" href="sgx-intro.html#term-Attestation"><span class="xref std std-term">Attestation</span></a>. Broadly
speaking, attestation is a mechanism for a remote user to verify that the
application runs on a real hardware in an up-to-date TEE with the expected
initial state.</p>
<p>There are two types of attestation: <a class="reference internal" href="sgx-intro.html#term-Local-Attestation"><span class="xref std std-term">Local Attestation</span></a> and
<a class="reference internal" href="sgx-intro.html#term-Remote-Attestation"><span class="xref std std-term">Remote Attestation</span></a>. Local attestation is used when two TEEs run on the
same physical machine and remote attestation is used when a user attests a TEE
running on a remote physical machine. In the following, even though Gramine
attestation flows are designed to be TEE-agnostic, we discuss only <a class="reference internal" href="glossary.html#term-SGX"><span class="xref std std-term">SGX</span></a>
attestation flows (the SGX flows are currently the only ones implemented).</p>
<p>By itself, remote attestation only provides the assurance to the user that the
remotely executing TEE is trusted, that the correct code is executed and that
the data is processed securely. In addition to this assurance, the user needs to
create a <a class="reference internal" href="glossary.html#term-Secure-Channel"><span class="xref std std-term">Secure Channel</span></a> for trusted communication with the remote TEE.
In many cases, the user also wants <a class="reference internal" href="glossary.html#term-Secret-Provisioning"><span class="xref std std-term">Secret Provisioning</span></a> to transparently
provision secret keys and other sensitive data to the remote TEE.</p>
<p>Gramine provides support for all three levels of attestation flows:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="sgx-intro.html#term-Local-Attestation"><span class="xref std std-term">Local Attestation</span></a> and <a class="reference internal" href="sgx-intro.html#term-Remote-Attestation"><span class="xref std std-term">Remote Attestation</span></a> are exposed to the
application via <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> pseudo-filesystem. SGX local attestation
in Gramine relies on the <code class="docutils literal notranslate"><span class="pre">EREPORT</span></code> hardware instruction. SGX remote
attestation uses the Intel SGX PSW’s AESM service and the Intel IAS service
(for EPID flows) or DCAP libraries (for ECDSA/DCAP flows) under the hood.</p></li>
<li><p><a class="reference internal" href="glossary.html#term-Secure-Channel"><span class="xref std std-term">Secure Channel</span></a> is constructed using the RA-TLS libraries.
<a class="reference internal" href="glossary.html#term-RA-TLS"><span class="xref std std-term">RA-TLS</span></a> uses raw <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> pseudo-files under the hood.</p></li>
<li><p><a class="reference internal" href="glossary.html#term-Secret-Provisioning"><span class="xref std std-term">Secret Provisioning</span></a> is built using the Secret Provisioning libraries.
These libraries use RA-TLS under the hood.</p></li>
</ol>
<p>Applications running under Gramine can use each of the above three levels to
build their attestation flows. Each next level builds on the previous one and
exposes a simpler API to the application (but also is more restricted in its
functionality).</p>
<p>In addition to these three Gramine-native flows, there is also an option to use
third-party attestation &amp; secret provisioning solutions. This option may be
better suited for complex deployments, for example, deploying chained
micro-services in the public cloud. Please refer to <a class="reference internal" href="#third-party-solutions"><span class="std std-ref">Third-Party Solutions</span></a>
for specific examples.</p>
<section id="remote-attestation-flows-for-epid-and-dcap">
<h2>Remote Attestation flows for EPID and DCAP<a class="headerlink" href="#remote-attestation-flows-for-epid-and-dcap" title="Permalink to this headline"></a></h2>
<p>Remote attestation in Intel SGX comes in two flavours: <a class="reference internal" href="sgx-intro.html#term-EPID"><span class="xref std std-term">EPID</span></a> and
<a class="reference internal" href="sgx-intro.html#term-DCAP"><span class="xref std std-term">DCAP</span></a>. The former is used in client machines whereas the latter is used
in data center environments. The details of these flows will be described in the
following sections. Here we give a high-level description of both of these
remote attestation schemes.</p>
<a class="reference external image-reference" href="./img/epid.svg"><img alt="Figure: EPID based remote attestation in Intel SGX" src="_images/epid.svg" /></a>
<p>The diagram above shows EPID based remote attestation. The user application runs
in an SGX enclave on a remote untusted machine, whereas the end user waits for
the attestation evidence from this enclave on a trusted machine.</p>
<p>EPID based remote attestation starts with the enclavized user application
opening the special file <code class="docutils literal notranslate"><span class="pre">/dev/attestation/user_report_data</span></code> for write (step
1). Under the hood, Gramine uses the <code class="docutils literal notranslate"><span class="pre">EREPORT</span></code> hardware instruction to
generate an <a class="reference internal" href="sgx-intro.html#term-SGX-Report"><span class="xref std std-term">SGX Report</span></a> (step 2). After the SGX report is generated, the
application opens another special file <code class="docutils literal notranslate"><span class="pre">/dev/attestation/quote</span></code> for read (step
3). Under the hood, Gramine communicates with the <a class="reference internal" href="sgx-intro.html#term-Quoting-Enclave"><span class="xref std std-term">Quoting Enclave</span></a> to
receive the <a class="reference internal" href="sgx-intro.html#term-SGX-Quote"><span class="xref std std-term">SGX Quote</span></a> (step 4). In turn, the Quoting Enclave uses the
EPID key provided by the <a class="reference internal" href="sgx-intro.html#term-Provisioning-Enclave"><span class="xref std std-term">Provisioning Enclave</span></a> (step 5, only during
initial deployment of this SGX machine). The Provisioning Enclave requests the
EPID key associated with this SGX machine from the internet-accessible
<a class="reference internal" href="sgx-intro.html#term-Intel-Provisioning-Service"><span class="xref std std-term">Intel Provisioning Service</span></a> (step 6, only during initial deployment).
The Quoting Enclave generates the SGX quote from the provided-by-application SGX
report and sends it back to the enclavized user application. The application
stores this SGX quote in its enclave memory and can later send it to the remote
user (verifier) upon request. When the remote user wants to validate the SGX
enclave, it requests remote attestation with it, and the enclavized application
forwards the SGX quote to the remote trusted machine (step 8). Finally, the
remote user consults the <a class="reference internal" href="sgx-intro.html#term-Intel-Attestation-Service"><span class="xref std std-term">Intel Attestation Service</span></a> (by forwarding the
SGX quote to this service), which returns back whether this SGX quote can be
trusted (step 9). Finally, the remote user also verifies the enclave
measurements embedded in the SGX quote against the expected ones. After this
verification procedure, the remote user can trust the SGX enclave on the
untrusted machine and start sending inputs/receiving enclave outputs.</p>
<a class="reference external image-reference" href="./img/dcap.svg"><img alt="Figure: DCAP based remote attestation in Intel SGX" src="_images/dcap.svg" /></a>
<p>The diagram above shows DCAP based remote attestation. The DCAP flows are very
similar to EPID flows, but rather than using the EPID keys and consulting the
Intel Attestation Service, the DCAP flows instead use the classic PKI with X.509
certificate chains.</p>
<p>The DCAP flows are the same as EPID flows in steps 1-4. However, the Quoting
Enclave talks to the <a class="reference internal" href="sgx-intro.html#term-Provisioning-Certification-Enclave"><span class="xref std std-term">Provisioning Certification Enclave</span></a> (PCE) rather
than the <a class="reference internal" href="sgx-intro.html#term-Provisioning-Enclave"><span class="xref std std-term">Provisioning Enclave</span></a> (step 5). The PCE uses another Intel
service called <a class="reference internal" href="sgx-intro.html#term-Intel-Provisioning-Certification-Service"><span class="xref std std-term">Intel Provisioning Certification Service</span></a> (PCS) to obtain
the attestation collateral: attestation certificates and certificate revocation
lists for the SGX machine (step 6). Also, the end user does not need to consult
a web service from Intel each time a new SGX quote arrives – instead the end
user periodically fetches the DCAP attestation certificates and caches them on a
local machine (preliminary step 0). When the SGX quote arrives, the user
compares the certificates embedded in the quote against these cached
certificates (step 9).</p>
</section>
<section id="low-level-dev-attestation-interface">
<h2>Low-level <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> interface<a class="headerlink" href="#low-level-dev-attestation-interface" title="Permalink to this headline"></a></h2>
<p>The first level of the <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> pseudo-filesystem exposes the
low-level abstractions of <em>attestation report</em> and <em>attestation quote</em> objects
(<a class="reference internal" href="sgx-intro.html#term-SGX-Report"><span class="xref std std-term">SGX Report</span></a> and <a class="reference internal" href="sgx-intro.html#term-SGX-Quote"><span class="xref std std-term">SGX Quote</span></a> in SGX parlance), in the form of the
below pseudo-files:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/attestation_type</span></code> pseudo-file can be opened for read and
contains the name of the attestation scheme used (currently one of <code class="docutils literal notranslate"><span class="pre">none</span></code>,
<code class="docutils literal notranslate"><span class="pre">epid</span></code> and <code class="docutils literal notranslate"><span class="pre">dcap</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/user_report_data</span></code> pseudo-file can be opened for read or
write access. Typically, it is opened and written into before opening and
reading from the <code class="docutils literal notranslate"><span class="pre">/dev/attestation/report</span></code> and <code class="docutils literal notranslate"><span class="pre">/dev/attestation/quote</span></code>
files, such that they can use the user-provided report data. In case of Intel
SGX, user report data can be an arbitrary string of size 64B; this string is
embedded in the SGX report/quote.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/target_info</span></code> pseudo-file can be opened for read and write.
Typically, it is opened and written into before opening and reading from the
<code class="docutils literal notranslate"><span class="pre">/dev/attestation/report</span></code> file, such that the latter can use the provided
target info. In case of Intel SGX, target info is an opaque blob of size 512B.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/my_target_info</span></code> pseudo-file can be opened for read and
will contain the target info of this enclave. The resulting target info blob
can be passed to another enclave as part of the local attestation flow. In
case of Intel SGX, target info is an opaque blob of size 512B.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/report</span></code> pseudo-file can be opened for read and will
contain the SGX report. Before opening this file for read, user report data
must be written into <code class="docutils literal notranslate"><span class="pre">/dev/attestation/user_report_data</span></code> and target info
must be written into <code class="docutils literal notranslate"><span class="pre">/dev/attestation/target_info</span></code>. Otherwise the obtained
report will contain incorrect or stale user report data and target info.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/quote</span></code> pseudo-file can be opened for read and will contain
the SGX quote. Before opening this file for read, user report data must be
written into <code class="docutils literal notranslate"><span class="pre">/dev/attestation/user_report_data</span></code>. Otherwise the obtained
attestation quote will contain incorrect or stale user report data.</p></li>
</ul>
<p>The resulting report can be passed to another TEE as part of the local
attestation flow. In case of Intel SGX, the obtained report is the SGX report
created by the <code class="docutils literal notranslate"><span class="pre">EREPORT</span></code> hardware instruction.</p>
<p>The resulting quote can be passed to another TEE or service as part of the
remote attestation flow. In case of Intel SGX, the obtained quote is the SGX
quote created by the <a class="reference internal" href="sgx-intro.html#term-Quoting-Enclave"><span class="xref std std-term">Quoting Enclave</span></a> (accessed via the AESM service).</p>
<p>Using the above files, the user application may construct arbitrary attestation
flows. Typically, the application will write a secure hash of the unique public
key generated by the TEE instance into <code class="docutils literal notranslate"><span class="pre">/dev/attestation/user_report_data</span></code>,
such that when the remote user receives the SGX quote (with user report data
embedded), the remote user can tie the TEE instance to the TEE’s public key.</p>
<p>Please note that these files are process-local, so there is no need to add
locking between processes when setting the user report data/target info or
reading the report/quote.</p>
<p>An example of this low-level interface can be found under
<code class="docutils literal notranslate"><span class="pre">libos/test/regression/attestation.c</span></code>. Here is a C code snippet of how the
remote attestation flow may look like in your application:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sgx_report_data_t</span><span class="w"> </span><span class="n">user_report_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_report_data</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;some-dummy-data&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;some-dummy-data&quot;</span><span class="p">));</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">fd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/attestation/user_report_data&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_WRONLY</span><span class="p">);</span><span class="w"></span>
<span class="n">write</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">user_report_data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">user_report_data</span><span class="p">));</span><span class="w"></span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="n">quote</span><span class="p">[</span><span class="n">SGX_QUOTE_MAX_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/attestation/quote&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span><span class="w"></span>
<span class="n">read</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">quote</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">quote</span><span class="p">));</span><span class="w"></span>

<span class="cm">/* ...send `quote` to the remote user for verification... */</span><span class="w"></span>
</pre></div>
</div>
<p>The remote user should receive this attestation quote and verify it. In case of
Intel SGX, this verification flow depends on whether the SGX remote attestation
is EPID based or DCAP/ECDSA based:</p>
<ul class="simple">
<li><p><a class="reference internal" href="sgx-intro.html#term-EPID"><span class="xref std std-term">EPID</span></a> based quote verification is done with the help of the Intel
Attestation Service (<a class="reference internal" href="sgx-intro.html#term-IAS"><span class="xref std std-term">IAS</span></a>). In particular, the remote user should
forward the received SGX quote to the well-known IAS endpoint via a secure
internet connection and get the IAS attestation report (not to be confused
with SGX report!) back. The user then should examine the contents of the IAS
attestation report and decide whether to trust the remote SGX enclave or not.</p></li>
<li><p><a class="reference internal" href="sgx-intro.html#term-DCAP"><span class="xref std std-term">DCAP</span></a> based quote verification is done with the help of the Intel DCAP
libraries. These libraries encapsulate the complicated DCAP flows (extracting
Intel SGX certificates from the
<a class="reference internal" href="sgx-intro.html#term-Intel-Provisioning-Certification-Service"><span class="xref std std-term">Intel Provisioning Certification Service</span></a>, caching these certificates
in the Provisioning Certificate Caching Service, etc.).</p></li>
</ul>
<p>Gramine does <em>not</em> provide any pseudo-files under <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> for
verification of the attestation quote. Instead, the remote user is encouraged to
use the <strong class="program">quote_dump</strong>, <strong class="program">ias_request</strong> and
<strong class="program">verify_ias_report</strong> tools shipped together with Gramine (for
EPID based quote verification) or to use the Intel DCAP libraries and tools (for
DCAP based quote verification).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> pseudo-filesystem also exposes pseudo-files to set the
encryption keys (see also <a class="reference internal" href="manifest-syntax.html"><span class="doc">Manifest syntax</span></a>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/attestation/keys/&lt;key_name&gt;</span></code> file contains the encryption key with a
given name (the default key name is <code class="docutils literal notranslate"><span class="pre">default</span></code>). Typically, it is opened
before the actual application runs and filled with a 128-bit key obtained from
a remote secret provisioning service. The format of the file is a 16-byte raw
binary value.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Previously, <code class="docutils literal notranslate"><span class="pre">/dev/attestation/protected_files_key</span></code> was used for setting the
default encryption key, and Gramine still supports that file for backward
compatibility.</p>
<p>Note that the old file (<code class="docutils literal notranslate"><span class="pre">/dev/attestation/protected_files_key</span></code>) uses a
32-character hex value, and the new files
(<code class="docutils literal notranslate"><span class="pre">/dev/attestation/keys/&lt;key_name&gt;</span></code>) use a 16-byte raw binary value.</p>
</div>
</section>
<section id="mid-level-ra-tls-interface">
<h2>Mid-level RA-TLS interface<a class="headerlink" href="#mid-level-ra-tls-interface" title="Permalink to this headline"></a></h2>
<p>As can be seen from the previous section, the low-level <code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code>
interface provides only bare-bones TEE attestation functionality and does not
provide any convenient interface for user-side quote verification. Also, that
low-level interface provides no means to transfer any data to/from the TEE other
than the attestation quote itself.</p>
<p><a class="reference internal" href="glossary.html#term-RA-TLS"><span class="xref std std-term">RA-TLS</span></a> interface hides the complexity of the low-level
<code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> flows and provides a simple and powerful abstraction of a
TLS connection between the TEE and the remote user (enhanced with
remote-attestation flows). Using RA-TLS, the application can securely send and
receive arbitrary data to/from the remote user. RA-TLS is currently tied to
Intel SGX but can be adapted for other TEEs.</p>
<p>RA-TLS integrates Intel SGX remote attestation into the TLS connection setup.
Conceptually, it extends the standard X.509 certificate with SGX-related
information (SGX quote). The additional information allows the remote user
(verifier) of the certificate to verify that it is indeed communicating with an
SGX enclave (attester).</p>
<a class="reference external image-reference" href="./img/ratls.svg"><img alt="Figure: The X.509 certificate generated by RA-TLS" src="_images/ratls.svg" /></a>
<p>The diagram above shows the standard X.509 certificate generated by RA-TLS (the
diagram shows the DCAP based RA-TLS certificate, but the EPID based RA-TLS
certificate is conceptually similar). This certificate is self-signed because
the actual chain of trust is stored in the Intel SGX certificates embedded in
the SGX quote. The most important concept behind the RA-TLS certificate is that
it embeds the SGX quote (in one of the unused X.509 extension fields), which in
turn embeds the SGX report and the complete Intel SGX certificate chain.
Therefore, the RA-TLS certificate contains all the SGX-relevant information.
Also, notice how the SGX report’s REPORTDATA field contains the secure hash of
the ephemeral public key generated by the enclavized application – this is how
this RA-TLS certificate is tied to the enclavized application that generated it.</p>
<p>RA-TLS is shipped as three libraries: <code class="docutils literal notranslate"><span class="pre">ra_tls_attest.so</span></code>, EPID based
<code class="docutils literal notranslate"><span class="pre">ra_tls_verify_epid.so</span></code> and DCAP/ECDSA based <code class="docutils literal notranslate"><span class="pre">ra_tls_verify_dcap.so</span></code>.
The interfaces exposed by these libraries can be found in the following header:
<code class="file docutils literal notranslate"><span class="pre">tools/sgx/ra-tls/ra_tls.h</span></code>.</p>
<p>The examples of using RA-TLS can be found under <code class="docutils literal notranslate"><span class="pre">CI-Examples/ra-tls-mbedtls</span></code>.</p>
<section id="ra-tls-attest-so">
<h3><code class="docutils literal notranslate"><span class="pre">ra_tls_attest.so</span></code><a class="headerlink" href="#ra-tls-attest-so" title="Permalink to this headline"></a></h3>
<p>This library creates the self-signed RA-TLS certificate. This library must be
loaded into the SGX enclave. The library relies on the pseudo-FS
<code class="docutils literal notranslate"><span class="pre">/dev/attestation</span></code> to retrieve the SGX quote and embed it into the RA-TLS
certificate. The library is <em>not</em> thread-safe.</p>
<p>The library expects the following information in the manifest for EPID based
attestation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sgx.remote_attestation</span> <span class="pre">=</span> <span class="pre">&quot;epid&quot;</span></code> – EPID remote attestation is enabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sgx.ra_client_spid</span></code> – client SPID for EPID remote attestation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sgx.ra_client_linkable</span></code> – client linkable/unlinkable attestation mode.</p></li>
</ul>
<p>For DCAP/ECDSA based attestation, the library expects instead:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sgx.remote_attestation</span> <span class="pre">=</span> <span class="pre">&quot;dcap&quot;</span></code> – DCAP remote attestation is enabled.</p></li>
</ul>
<p>The library uses the following environment variables if available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_CERT_TIMESTAMP_NOT_BEFORE</span></code> – the generated RA-TLS certificate uses
this timestamp-not-before value, in the format “20010101000000” (this is also
the default value if environment variable is not available).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_CERT_TIMESTAMP_NOT_AFTER</span></code> – the generated RA-TLS certificate uses
this timestamp-not-after value, in the format “20301231235959” (this is also
the default value if environment variable is not available).</p></li>
</ul>
</section>
<section id="ra-tls-verify-epid-so">
<h3><code class="docutils literal notranslate"><span class="pre">ra_tls_verify_epid.so</span></code><a class="headerlink" href="#ra-tls-verify-epid-so" title="Permalink to this headline"></a></h3>
<p>This library contains the verification callback that should be registered with
the TLS library during verification of the TLS certificate. It verifies the
RA-TLS certificate and the SGX quote by sending it to the Intel Attestation
Service (IAS) and retrieving the attestation report from IAS. This library is
<em>not</em> thread-safe.</p>
<p>The library uses the following SGX-specific environment variables, representing
SGX measurements:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_MRSIGNER</span></code> – verify that the attesting enclave has this
<code class="docutils literal notranslate"><span class="pre">MRSIGNER</span></code>. This is a hex string.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_MRENCLAVE</span></code> – verify that the attesting enclave has this
<code class="docutils literal notranslate"><span class="pre">MRENCLAVE</span></code>. This is a hex string.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_ISV_PROD_ID</span></code> – verify that the attesting enclave has this
<code class="docutils literal notranslate"><span class="pre">ISV_PROD_ID</span></code>. This is a decimal string.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_ISV_SVN</span></code> – verify that the attesting enclave has this or higher
<code class="docutils literal notranslate"><span class="pre">ISV_SVN</span></code>. This is a decimal string.</p></li>
</ul>
<p>For each of these settings, you may specify the special value <code class="docutils literal notranslate"><span class="pre">any</span></code> to skip
verifying a particular measurement. This used to be the default, which would
be used if a particular environment variable wasn’t present. This behavior
has been deprecated and will become a hard error in the future.</p>
<p>The four SGX measurements above may be also verified via a user-specified
callback with the signature <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*callback)(char*</span> <span class="pre">mrenclave,</span> <span class="pre">char*</span> <span class="pre">mrsigner,</span>
<span class="pre">char*</span> <span class="pre">isv_prod_id,</span> <span class="pre">char*</span> <span class="pre">isv_svn)</span></code>. This callback must be registered via
<code class="docutils literal notranslate"><span class="pre">ra_tls_set_measurement_callback()</span></code>. The measurements from the received SGX
quote are passed as four arguments. It is up to the user to implement the
correct verification of SGX measurements in this callback (e.g., by comparing
against expected values stored in a central database).</p>
<p>The library also uses the following SGX-specific environment variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_ALLOW_OUTDATED_TCB_INSECURE</span></code> (optional) – whether to allow outdated
TCB as returned in the IAS attestation report or returned by the DCAP
verification library. Value <code class="docutils literal notranslate"><span class="pre">1</span></code> means “allow outdated TCB”. Note that
allowing outdated TCB is <strong>insecure</strong> and should be used only for debugging
and testing. Outdated TCB is not allowed by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_ALLOW_DEBUG_ENCLAVE_INSECURE</span></code> (optional) – whether to allow debug
enclaves (enclaves with <code class="docutils literal notranslate"><span class="pre">SECS.ATTRIBUTES.DEBUG</span></code> bit set to one). Value <code class="docutils literal notranslate"><span class="pre">1</span></code>
means “allow debug enclaves”. Note that allowing debug enclaves is
<strong>insecure</strong> and should be used only for debugging and testing. Debug enclaves
are not allowed by default.</p></li>
</ul>
<p>The library uses the following EPID-specific environment variables if available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_EPID_API_KEY</span></code> (mandatory) – client API key for EPID remote
attestation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_IAS_REPORT_URL</span></code> (optional) – URL for IAS “verify attestation
evidence” API endpoint. If not specified, the default hard-coded URL for IAS
is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_IAS_SIGRL_URL</span></code> (optional) – URL for IAS “Retrieve SigRL” API
endpoint. If not specified, the default hard-coded URL for IAS is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RA_TLS_IAS_PUB_KEY_PEM</span></code> (optional) – public key of IAS. If not specified,
the default hard-coded public key is used.</p></li>
</ul>
</section>
<section id="ra-tls-verify-dcap-so">
<h3><code class="docutils literal notranslate"><span class="pre">ra_tls_verify_dcap.so</span></code><a class="headerlink" href="#ra-tls-verify-dcap-so" title="Permalink to this headline"></a></h3>
<p>Similarly to <code class="docutils literal notranslate"><span class="pre">ra_tls_verify_epid.so</span></code>, this library contains the verification
callback that should be registered with the TLS library during verification of
the TLS certificate. Verifies the RA-TLS certificate and the SGX quote by
forwarding it to DCAP verification library (<code class="docutils literal notranslate"><span class="pre">libsgx_dcap_quoteverify.so</span></code>) and
checking the result. This library is <em>not</em> thread-safe.</p>
<p>The library uses the same SGX-specific environment variables as
<code class="docutils literal notranslate"><span class="pre">ra_tls_verify_epid.so</span></code> and ignores the EPID-specific environment variables.
Similarly to the EPID version, instead of using environment variables, the four
SGX measurements may be verified via a user-specified callback registered via
<code class="docutils literal notranslate"><span class="pre">ra_tls_set_measurement_callback()</span></code>.</p>
<p>The library expects all the DCAP infrastructure to be installed and working
correctly on the host.</p>
</section>
</section>
<section id="high-level-secret-provisioning-interface">
<h2>High-level Secret Provisioning interface<a class="headerlink" href="#high-level-secret-provisioning-interface" title="Permalink to this headline"></a></h2>
<p>In some cases, the mid-level interface of RA-TLS is an overkill. Sometimes all
the TEE application needs is a couple secrets provisioning into it and nothing
more. E.g., an image recognition application may only need a single encryption
key to decrypt the inputs (model file, classification file, image file) and the
same key to encrypt the outputs. Such an application doesn’t need a TLS
communication with the remote user but simply a way to securely obtain this
single key from a well-known location.</p>
<p>This is the scenario where the high-level <a class="reference internal" href="glossary.html#term-Secret-Provisioning"><span class="xref std std-term">Secret Provisioning</span></a> interface
comes into play. Secret Provisioning is shipped together with Gramine in the
form of (helper) shared libraries. These libraries are reference implementations
for the flows to provision secrets from a trusted machine (service, verifier) to
an enclavized application (client, attester). These libraries rely heavily on
RA-TLS and re-use the same configuration parameters as listed in the previous
section.</p>
<p>Secret Provisioning libraries hide the complexity of RA-TLS but use it under the
hood for communication between the enclavized application and the trusted
service. Conceptually, an enclavized client application and a trusted service
establish a secure RA-TLS communication channel via TLS mutual attestation. The
service sends its normal X.509 certificate for verification by client, whereas
the enclavized client sends its RA-TLS X.509 certificate with the SGX quote for
verification by the service. After this mutual attestation, the trust is
established, and the service provisions the secrets to the enclavized client.
The established TLS channel may be either closed after provisioning these
initial secrets or may be further used by both parties for continued secure
communication.</p>
<p>Secret Provisioning is shipped as three libraries: <code class="docutils literal notranslate"><span class="pre">secret_prov_attest.so</span></code>,
EPID based <code class="docutils literal notranslate"><span class="pre">secret_prov_verify_epid.so</span></code> and DCAP/ECDSA based
<code class="docutils literal notranslate"><span class="pre">secret_prov_verify_dcap.so</span></code>.</p>
<p>The examples of using RA-TLS can be found under <code class="docutils literal notranslate"><span class="pre">CI-Examples/ra-tls-secret-prov</span></code>.
The examples include minimalistic provisioning of constant-string secrets as
well as provisioning of an encryption key and its later use for encrypted files.</p>
<section id="secret-prov-attest-so">
<h3><code class="docutils literal notranslate"><span class="pre">secret_prov_attest.so</span></code><a class="headerlink" href="#secret-prov-attest-so" title="Permalink to this headline"></a></h3>
<p>This library is typically linked into enclavized applications. The application
calls into this library to initiate the RA-TLS session with the remote trusted
service for secret provisioning. Alternatively, the library runs before
application’s entry point, initializes the RA-TLS session, receives the secret
and stashes it in an environment variable <code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_SECRET_STRING</span></code>.
In both cases, the application may call into the library to continue secure
communication with the trusted party and/or to retrieve the secret. This
library is <em>not</em> thread-safe.</p>
<p>The library expects the same configuration information in the manifest and
environment variables as RA-TLS. In addition, the library uses the following
environment variables if available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_CONSTRUCTOR</span></code> (optional) – set it to <code class="docutils literal notranslate"><span class="pre">1/true/TRUE</span></code> to
initialize the RA-TLS session and retrieve the secret before the application
starts. By default, it is not set, thus secret provisioning must be explicitly
requested by the application.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_SET_KEY</span></code> (optional) – set it to the name of the key that
will be provisioned into the Gramine enclave as the secret. For example,
setting this environment variable to <code class="docutils literal notranslate"><span class="pre">default</span></code> will install the provisioned
key as the default encryption key for encrypted files. The key must be sent
(by the secret provisioning service) as a 32-char null-terminated AES-GCM
encryption key in hex format, similar to <code class="docutils literal notranslate"><span class="pre">fs.insecure__keys.[KEY_NAME]</span></code>
manifest option. This environment variable is checked only if
<code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_CONSTRUCTOR</span></code> is set. The library puts the provisioned key
into <code class="docutils literal notranslate"><span class="pre">/dev/attestation/keys/&lt;key_name&gt;</span></code> so that Gramine recognizes it.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Previously, <code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_SET_PF_KEY</span> <span class="pre">=</span> <span class="pre">1/true/TRUE</span></code> was used for
setting the <code class="docutils literal notranslate"><span class="pre">default</span></code> encryption key, and Gramine still supports that
environment variable for backward compatibility. It is deprecated and will be
removed in the next releases of Gramine.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_SERVERS</span></code> (optional) – a comma, semicolon or space
separated list of server names with ports to connect to for secret
provisioning. Example: <code class="docutils literal notranslate"><span class="pre">localhost:4433;trusted-server:443</span></code>. If not set,
defaults to <code class="docutils literal notranslate"><span class="pre">localhost:4433</span></code>. Alternatively, the application can specify it
as an argument of <code class="docutils literal notranslate"><span class="pre">secret_provision_start()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_CA_CHAIN_PATH</span></code> (required) – a path to the CA chain of
certificates to verify the server. Alternatively, the application can specify
it as an argument of <code class="docutils literal notranslate"><span class="pre">secret_provision_start()</span></code>.</p></li>
</ul>
<p>The secret may be retrieved by the application in two ways:</p>
<ul class="simple">
<li><p>Reading <code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_SECRET_STRING</span></code> environment variable. It is updated
only if <code class="docutils literal notranslate"><span class="pre">SECRET_PROVISION_CONSTRUCTOR</span></code> is set to true and if the secret is
representable as a string of maximum 4K characters.</p></li>
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">secret_provision_get()</span></code> function. It always updates its pointer
argument to the secret (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if secret provisioning failed).</p></li>
</ul>
</section>
<section id="secret-prov-verify-epid-so">
<h3><code class="docutils literal notranslate"><span class="pre">secret_prov_verify_epid.so</span></code><a class="headerlink" href="#secret-prov-verify-epid-so" title="Permalink to this headline"></a></h3>
<p>This library is typically linked into a normal, non-enclavized application
(secret provisioning service). The service calls into this library to listen for
clients in an endless loop. When a new client connects, the service initiates an
RA-TLS session with the client, verifies the RA-TLS X.509 certificate of the
client, and provisions the secret to the client if verification is successful.
The service can register a callback to continue secure communication with the
client (instead of simply closing the session after the first secret is sent to
the client). This library is <em>not</em> thread-safe. This library uses EPID based
RA-TLS flows underneath.</p>
<p>The library expects the same configuration information in the manifest and
environment variables as RA-TLS.</p>
</section>
<section id="secret-prov-verify-dcap-so">
<h3><code class="docutils literal notranslate"><span class="pre">secret_prov_verify_dcap.so</span></code><a class="headerlink" href="#secret-prov-verify-dcap-so" title="Permalink to this headline"></a></h3>
<p>Similarly to <code class="docutils literal notranslate"><span class="pre">secret_prov_verify_epid.so</span></code>, this library is used in
secret-provisioning services. The only difference is that this library uses
DCAP based RA-TLS flows underneath.</p>
<p>The library uses the same SGX-specific environment variables as
<code class="docutils literal notranslate"><span class="pre">secret_prov_verify_epid.so</span></code> and ignores the EPID-specific environment
variables. The library expects all the DCAP infrastructure to be installed and
working correctly on the host.</p>
</section>
</section>
<section id="third-party-solutions">
<span id="id1"></span><h2>Third-Party Solutions<a class="headerlink" href="#third-party-solutions" title="Permalink to this headline"></a></h2>
<p>The three Gramine-native interfaces described above are quite limited in their
functionality. For example, RA-TLS currently creates only self-signed X.509
certificates that may not fit well in traditional Public Key Infrastructure
(PKI) flows.  As another example, our Secret Provisioning service is only a
<em>minimal reference implementation</em>: it is not scalable, it cannot verify
multiple different enclaves, it doesn’t allow flexible attestation rules, etc.</p>
<p>Therefore, a more fully-fledged, centralized attestation &amp; secret provisioning
solution may be required. This is especially true in cloud deployments: in the
cloud, it makes sense to have a single service that manages remote attestation
and secret provisioning. The end users do <em>not</em> perform attestation of separate
enclaves but only perform attestation and verification of this single service.
This service itself runs in the SGX enclave, and is bootstrapped with a policy
file that contains all the secure measurements and policies for each of the
participating SGX applications.</p>
<p>Fortunately, there are several such solutions that integrate with Gramine. We
describe one of them below, and we will add more solutions in the future.</p>
<section id="edgeless-marblerun">
<h3>Edgeless Marblerun<a class="headerlink" href="#edgeless-marblerun" title="Permalink to this headline"></a></h3>
<a class="reference external image-reference" href="./img/marblerun.svg"><img alt="Figure: Edgeless Marblerun integration with Gramine" src="_images/marblerun.svg" /></a>
<p>Marblerun is the service mesh for confidential computing from Edgeless Systems.
Marblerun consists of two parts: the Coordinator (the centralized attestation &amp;
secret provisioning service) and the Marbles (separate Gramine applications).
The Coordinator needs to be deployed once in the cluster and the Marble
component needs to be integrated with each Gramine application. Marblerun
Coordinator is configured with a simple JSON document (the manifest). It
specifies the topology of the cluster, the infrastructure properties, and
provides configuration parameters for each Gramine application.</p>
<p>Marblerun integrates with Gramine using the “premain” trick. In essence,
instead of starting the Gramine application directly, Marblerun requires
modifications to the Gramine manifest file to start its “premain” executable
first. This “premain” executable attests itself to the Coordinator, receives
secrets from the Coordinator, patches command-line arguments, environment
variables and files with these secrets, and only then starts the main Gramine
application. This “premain” executable together with the Gramine application is
referred to as a Marble. For more details, see <a class="reference external" href="https://docs.edgeless.systems/marblerun/#/building-services/gramine">Marblerun docs on Gramine
integration</a>.</p>
<p>The Coordinator serves as a centralized service for remote attestation of
Marbles and provisioning of secrets to them. The Coordinator verifies the
identity and integrity of each newly spawned Marble before admitting it to the
trusted cluster. Each Marble tries to register itself with the Coordinator by
sending an activation request to it. This request contains the SGX quote, which
allows the Coordinator to verify that the Marble (and thus the Gramine
application) adheres to the Marblerun manifest in effect.</p>
<p>End users do not perform remote attestation on each Gramine application but
instead they only attest the Coordinator. After attesting the Coordinator and
verifying its manifest, the end user gains trust in the whole cluster.
Afterwards, the end user can establish conventional TLS connections to
individual Gramine applications in the cluster and use them as normal. The
Coordinator acts as a Certificate Authority (CA) for these connections.</p>
<p>For more information, refer to official Marblerun resources:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.marblerun.sh">Official website</a></p></li>
<li><p><a class="reference external" href="https://docs.edgeless.systems/marblerun/#/">Marblerun documentation</a></p></li>
<li><p><a class="reference external" href="https://github.com/edgelesssys/marblerun">GitHub repository</a></p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="manifest-syntax.html" class="btn btn-neutral float-left" title="Manifest syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="performance.html" class="btn btn-neutral float-right" title="Performance tuning and analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Gramine Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>